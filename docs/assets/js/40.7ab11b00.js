(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{157:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[t._v("#")]),t._v(" 面试题")]),t._v(" "),e("h2",{attrs:{id:"_1-异常捕获前端监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-异常捕获前端监控"}},[t._v("#")]),t._v(" 1.异常捕获前端监控")]),t._v(" "),e("h3",{attrs:{id:"前端监控目的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端监控目的"}},[t._v("#")]),t._v(" 前端监控目的")]),t._v(" "),e("ol",[e("li",[t._v("提升用户体验")]),t._v(" "),e("li",[t._v("更快的发现发现异常、定位异常、解决异常")]),t._v(" "),e("li",[t._v("了解业务数据，指导产品升级——数据驱动业务的思想")])]),t._v(" "),e("h3",{attrs:{id:"try-cache异常捕获"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#try-cache异常捕获"}},[t._v("#")]),t._v(" try...cache异常捕获")]),t._v(" "),e("ol",[e("li",[t._v("try cache无法捕捉setTimeout、then 回调函数中的错误，原因在于执行异步任务时，try cache所在函数已经出栈。try写在.then里面和setTimeout里面是可以的。")]),t._v(" "),e("li",[t._v("同理，try捕捉的回调如果和try所在函数在一次事件循环里就可以捕获错误。")]),t._v(" "),e("li",[t._v("Promise内部错误和Promise.reject的error try也无法捕获，因为Promise内部的错误需要.cache捕获")]),t._v(" "),e("li",[t._v("try可以捕获async、await的错误，因为生成器内部throw了")])]),t._v(" "),e("h2",{attrs:{id:"异常信息可以分为两类：运行时错误、接口错误。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异常信息可以分为两类：运行时错误、接口错误。"}},[t._v("#")]),t._v(" 异常信息可以分为两类：运行时错误、接口错误。")]),t._v(" "),e("h3",{attrs:{id:"运行时错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行时错误"}},[t._v("#")]),t._v(" 运行时错误")]),t._v(" "),e("p",[t._v("语法错误、类型错误、范围错误、引用错误、eval错误、URL错误、资源加载错误")]),t._v(" "),e("ol",[e("li",[t._v("非promise\na. window.addEventListener('error',{})")]),t._v(" "),e("li",[t._v("promise错误\na. Promise被reject且没有reject处理器的时候，会触发unhandlerejection事件，所以通过监听unhandlerejection的事件来捕获错误。Promise.allSettled都失败也是这个错误\nb.  window.addEventListener('unhandledrejection',")])]),t._v(" "),e("h3",{attrs:{id:"接口错误"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口错误"}},[t._v("#")]),t._v(" 接口错误")]),t._v(" "),e("p",[t._v("请求拦截、响应拦截中判断捕获上报")]),t._v(" "),e("h3",{attrs:{id:"埋点监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#埋点监控"}},[t._v("#")]),t._v(" 埋点监控")]),t._v(" "),e("p",[t._v("对于埋点方案：")]),t._v(" "),e("ul",[e("li",[t._v("手动埋点（侵入性强，和业务强关联，用于需要精确搜集并分析数据，不过该方式耗时耗力，且容易出现误差，后续要调整，成本较高）")]),t._v(" "),e("li",[t._v("可视化埋点（提供一个可视化的埋点控制台，只能在可视化平台已支持的页面进行埋点）")]),t._v(" "),e("li",[t._v("无埋点（就是全埋点，监控页面发生的一切行为，优点是前端只需要处理一次埋点脚本，不过数据量过大会产生大量的脏数据，需要后端进行数据清洗）。")])]),t._v(" "),e("h3",{attrs:{id:"上报方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上报方式"}},[t._v("#")]),t._v(" 上报方式")]),t._v(" "),e("p",[t._v("埋点通常采用new Image方式（通常是gif格式字节更小）来上传，上报的数据作为URL参数拼接到一个1x1像素的透明图片URL中")]),t._v(" "),e("ul",[e("li",[t._v("没有跨域问题")]),t._v(" "),e("li",[t._v("不会阻塞页面加载\n现在的浏览器如果支持Navigator.sendBeacon(url, data)方法，优先使用该方法来实现，它的主要作用就是用于统计数据发送到web服务器。当然如果不支持的话就继续使用图片的方式来上传数据。")])]),t._v(" "),e("h3",{attrs:{id:"sdk"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sdk"}},[t._v("#")]),t._v(" SDK")]),t._v(" "),e("p",[t._v("简化开发过程并提高效率")]),t._v(" "),e("h2",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}],!1,null,null,null);a.default=s.exports}}]);